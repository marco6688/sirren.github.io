---
title: Redis-面试题整理
date: 2019-08-11 13:51:18
categories:
- redis
tags:
- redis
---

## 什么是redis

redis本质上是一个key->value的内存数据库，整个数据统统加到内存中进行操作，定期通过异步操作把数据flush到硬盘上进行操作

## redis的全名是什么

REmote DIctionary Server

## redis的优缺点

1. redis是纯内存操作，性能十分出色，每秒可以处理10w次的读写操作
2. 支持多重数据类型，单个value的最大限制是1GB
3. 可以设置key的过期时间
4. redis的主要缺点是数据容量受到物理内存的限制，不能用作海量数据的高性能读写。因此redis的适用场景主要局限在较小数据量的高兴鞥操作和运算上
5. 支持事物，所有操作要不全部执行，要么全部不执行

## redis与memcache的区别

1. memcache支持数据类型单一，redis支持多重数据类型
2. redis的数据比memcache快的多
3. redis支持数据持久化
4. 使用底层模型不同 它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。 Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。 

## reids支持哪些数据类型

字符串，列表，集合，有序集合，哈希表

## redis主要占用的物理资源

内存

## redis 的数据淘汰策略

noeviction 返回错误当内存限制达到并返回客户端尝试执行会让更多内存被使用的命令（大部分的写入命令，但del和几个例外）

allkeys-lru 尝试收回最少使用的键，使得新添加的数据有空间存放
volatile-lru 上市收回最少使用的键，但仅限于在过期的集合的键，使得新添加的数据有空间存放
allkeys-random 回收随机的键，使得新添加的数据有空间存放
volatile-random 回收随机的键，使得新添加的数据有空间存的，仅限于在过期集合的键
volatile-ttl 回收过期的键，并且优先回收存活时间较短的键，使得新添加的数据有空间存放

## redis为什么没有windows版本

因为linux版本已经相当稳定，而且用户量也很大，无需开发windows版本，而且会带来兼容性的问题

## 字符串类型的值能存储的最大容量

String类型：一个String类型的value最大可以存储512M

List类型：list的元素个数最多为2^32-1个，也就是4294967295个。

Set类型：元素个数最多为2^32-1个，也就是4294967295个。

Hash类型：键值对个数最多为2^32-1个，也就是4294967295个。

Sorted set类型：跟Set类型相似。

## redis支持多少个key

Redis最多可以处理2个32次方键，并且在实践中经过测试，每个实例至少处理2.5亿个键。

每个哈希，列表，集合和有序集合可以容纳2 32个元素。

换句话说，您的限制很可能是系统中的可用内存。

## redis是单线程的，如何利用多核cpu

CPU不会成为redis的瓶颈，因为redis通常是内存或者网络绑定。使用管道（pipelining）在一般的的linux系统上每秒可以提供100万个请求，如果应用程序主要使用O(N)或者O(log(N))命令，则不会使用太多的CPU

但是为了最大化CPU的使用率，可以启动多个实例，将他们视为不同的服务器，在某些时候可能还不够，这时候应该考虑进行分片

在redis4.0版本中引入多线程，这仅限于后台删除对象

## 为什么要要把所有的数据放到内存中

redis为了更快的读写速度将数据全部都读到了内存中，并通过异步的方式将数据写入磁盘

所以redis局域更快速的数据持久化的特性，如果不放到内存中，磁盘IO将会严重影响到redis的性能

## redis集群方案

1.codis。

目前用的最多的集群方案，基本和twemproxy一致的效果，但它支持在 节点数量改变情况下，旧节点数据可恢复到新hash节点。

2.redis cluster3.0自带的集群，特点在于他的分布式算法不是一致性hash，而是hash槽的概念，以及自身支持节点设置从节点。具体看官方文档介绍。

3.在业务代码层实现，起几个毫无关联的redis实例，在代码层，对key 进行hash计算，然后去对应的redis实例操作数据。 这种方式对hash层代码要求比较高，考虑部分包括，节点失效后的替代算法方案，数据震荡后的自动脚本恢复，实例的监控，等等

## Redis集群方案什么情况下会导致整个集群不可用

当abc三个节点的集群，在没有复制模型的情况下，B节点失败了，那么整个集群就会缺少B节点的数据

## mysql中有2000w的数据，redis中只存20w，如何保证redis的数据都是热点数据

redis内存上升到一定的大小时会执行数据淘汰策略

## redis的适用场景

* 会话缓存

> 在一些对数据一致性要求不严格的场景的时候，适用redis可以提供数据持久化

* 全页缓存

> 除了基本的会话token之外，redis还可以提供很简单的FPC平台。在一致性上，即使重启了redis，因为是磁盘的持久化，用户也不会看到页面加载速度的下降

* 队列

> redis提供了list和set的操作，这使得redis可以当做一个很好的消息队列平台来使用

* 排行榜和计数器

> redis的集合和有序集合可以很好的提供这些内容

* 发布订阅

> redis的发布订阅功能在很多地方可以当做异步通知来使用

## redis的哈希槽

redis集群没有使用一致性hash，而是引入了哈希槽的概念，redis集群有16384（2的14次方）个哈希槽，每个可以对CRC16效验后对16384取模来决定放在哪个槽，几群的每个节点负责一部分的hash槽

## redis的主从复制模型是怎么样子的

为了使部分节点在失败或者大部分节点无法通讯的情况下集群仍可用，所以集群使用了主从复制模型，每个节点都会有n-1个复制模型

## redis集群的主从复制模型会有写操作丢失吗

redis并不能保证数据的强一致性，这意味着在实际中集群在特定条件下可能会丢失写操作

## redis 集群写数据丢失的场景

1. 异步复制
2. 主从切换

假设集群发生在网络分布，那么集群可能分布为两方，大多数A、C、A1、B1、C1，而少数的一方B和客户端Z1.
在集群忘了断开期间，B仍然可以接受Z1发送的写命令：

* 如果断开时间短，那么集群正常运行
* 如果断开时间长，使得大多数的节点把B1上升为主节点，那么在这期间发送至B的写命令将会丢失

在网络分区期间，客户端想直接点B发送的命令最大时间是有限制的，这一时间称为**节点超时时间（node timeout）**，是redis集群的一个重要配置项：

* 对于大多数的一方来说，在这个时间内主节点未能重新连接上集群，那么集群会 把这个主节点设置为下线，并且使用从节点代替主节点进行工作
* 对于少数的一方来说，如果主节点未能在这个时间内重新连接集群，那么他将停止处理写明令，并向客户端报错

## redis集群之间是如何复制的

异步复制

## redis集群如何选择数据库

redis集群无法选择数据库，默认在0数据库

## redis的事物

事物是一个单独的隔离操作：事物的所有命令都会序列化、按树勋的执行，事物在执行过程中，不会被其他客户端请求打断

事物是一个原子操作：事物的命令要么全部被执行，要么全部都不执行


## Redis事务相关的命令有哪几个？
MULTI、EXEC、DISCARD、WATCH
      
## Redis key的过期时间和永久有效分别怎么设置

EXPIRE和PERSIST命令

## Redis如何做内存优化

尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。

比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面。

## redis为什么那么快

1. 完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；

2. 数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；

3. 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；

4. 使用多路I/O复用模型，非阻塞IO；

5. 使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；

以上几点都比较好理解，下边我们针对多路 I/O 复用模型进行简单的探讨：

（1）多路 I/O 复用模型

多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。

这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。

## 其他的几种模型

1. 单进程多线程模型：MySQL、Memcached、Oracle（Windows版本）；

2. 多进程模型：Oracle（Linux版本）；

3. Nginx有两类进程，一类称为Master进程(相当于管理进程)，另一类称为Worker进程（实际工作进程）。启动方式有两种：

（1）单进程启动：此时系统中仅有一个进程，该进程既充当Master进程的角色，也充当Worker进程的角色。

（2）多进程启动：此时系统有且仅有一个Master进程，至少有一个Worker进程工作。

（3）Master进程主要进行一些全局性的初始化工作和管理Worker的工作；事件处理是在Worker中进行的。