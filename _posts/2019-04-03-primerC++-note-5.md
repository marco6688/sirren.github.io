---
title: PrimerC++-函数
date: 2019-04-03 15:42:01
categories:
- 读书笔记
tags:
- 读书笔记
- C++
---

本篇介绍函数的定义声明，以及传参和返回结果，c++中允许重载函数和函数指针的一些知识

# 函数基础

函数是一个命名了的代码块，我们通过调用函数执行获得相应的代码，函数可以有0个或者多个参数，而且会返回一个结果

一个函数由返回类型，函数名字，0个或者多个形参组成的列表和函数体组成。形参由逗号隔开，位于函数名后的小括号内

```c++

//编写一个求数的阶乘程序，n的阶乘是从1到n的乘积

int function fact(int val){
	int ret = 1;
	while(ret>1){
		ret *= val--;
	}
}

//调用函数
int main(){
	int j = fact(10);
	cout<<"10 is:"<<j<<endl;
	return 0 ;
}
```
## 局部函数

在C++中名字有作用域，对象有生命周期

- 名字的作用域是程序文本的一部分，名字在其中可见
- 对象的声明周期是程序执行过程中该对象存在的一段时间

**自动对象**是指普通对象所对应的对象在函数控制路径经过变量定义语句时，创建该对象，当达到定义块末尾时销毁该对象

**局部静态对象**局部变量的生命周期贯穿函数调用及以后的时间

## 函数声明

函数声明和函数定义类型，唯一的区别就是没有函数体

函数可以被定义一次，但可以被多次声明

# 参数传递

当实参是引用类型时，我们称之为**引用传递**，引用形参也是他对应实参的别名

当实参的值拷贝给形参时，形参和实参是两个独立的对象，我们称之为**按值传递**

## 传值参数

指针形参，当执行指针拷贝操作时，拷贝的是指针的值，拷贝之后两个指针是不同的指针，因为指针可以使我们间接的访问他所指的对象，所以通过指针可以修改它所指对象的值

## 传引用参数

拷贝大的类型对象或者容器对象比较低效，甚至有的类类型不知道拷贝操作，当某些对象不支持拷贝操作时，函数只能通过引用形参的方式访问该类的对象

一个对象只能返回一个值，当函数需要返回多个值的时候，我们可以通过按引用传递改变引用对象的值，已达到隐式返回多个值的目的

```

int main(){
	vector<int> aa;
	aa.push_back(1);
	aa.push_back(2);
	aa.push_back(3);
	aa.push_back(4);
	int num = 0;
	int a1 = sum_num(aa,num);
}
int sum_num(vector<int> arr,int &cut ){
    int num = 0;
    for(int i=0;i<arr.size();i++){
        num += arr[i];
        cut++;
    }
    return num;
}

```

## const形参和实参

当用实参初始化形参时会忽略掉顶层const，当形参有顶层const时，传给他常量对象和非常量对象都是可以的

```

void fuc(const int i){
//i可以读取，但是不能更改
}

void fuc(int i){
//错误，重复定义函数
}

```

形参的初始化方式和和变量的初始化方式是一样的

把不会改变的形参定义成引用是一种比较常见的错误，可以将该形参定义成常量引用

## 数组形参

数组有两个特殊性质对定个和使用上有影响。第一个是数组不允许拷贝，使用数组时会转换成其指针。

```
//下面的三个函数是等价的
//每个函数都是一个const int*的形参
void(const int*);
void(const int[0]);
void(const int[10]);


int i=0; j[2] = {1,2};
print(&i);//转换成int *
print(j);//j转换成int * 指向j[0]

```

数组是以指针的形式传递给数组的，所以函数一开始不知道数组的确切大小，调用者应该为此提供一些额外的信息，管理指针形参常用的三个技术

- 使用标记指定数组长度

```C++
void print(const *cp){
	if(cp){
		while(*cp){
			cout<<*cp++;
		}
	}
}

```

- 使用标准库规范


```C++
void print(const int *beg,const int *end){
	while(beg!=end){
		cout<<*beg++;
	}
}

print(j.begin(),j.end());
int j[] = {0,1};


```

- 显示传递一个表示数组大小的形参

```C++

void print(const int ia[],size_t size){
	for(size_t i=0 i!=size;++i){
		cout<<ia[i]<<endl;
	}
}

int j[] = {0,1};
print(j,end(i)-begin(j));

```

- 数组形参和const

当我们不需要对数组形参进行写操作的时候数组形参应该是指向const指针，只有函数再确认改变元素之的时候才把形参定义成非常量指针

- 数组引用形参

C++允许把变量定义成为数组的引用，形参也可以是数组的引用，此时形参绑定到对应的实体上，也就是绑定到数组上

```

void print(int (&arr)[10]){
	for(auto elem:arr){
		cout<<elem<<endl;
	}
}
int i=0;j[2]={0,1};
int k[10]={0,1,2,3,4,5,6,7,8,9};
print(&i);	//错误，实参不是含义10个整数的数组
print(j);		//错误，实参不是含义10个整数的数组
print(k);		//正确


```

- 传递多维数组

C++中没有真正意义的多维数组，和所有数组一样，当将多维数组传递给函数时，真正传递的是首元素的指针

```

//matrix的神明看起来是一个二维数组，实际上形参是包含10个整数的数组的指针。
void print(int (*matrix)[10],int rowSize);
//等价于
void print(int matrix[][10],int rowSize);

```

## main：处理命令行选项

```

//prog -d -o ofile data0
int main(int argc,char *argv[]){}
//因为第二个参数是一个数组，所以也可以使用以下定义
int main(int argc,char **argv){}
//以上示例，argc应该等于5，argv应该是以下表示
argv[0] = "prog";
argv[1] = "-d";
argv[2] = "-o";
argv[3] = "ofile";
argv[4] = "data0";

```

## 含有可变形参的函数

在无法预知应该向函数传递多少个实参的时候，如果所有实参的类型相同可以传递一个名为initializer_list的标准库类型。如果实参的类型不同，可以编写一个特殊的函数，也就是可变参数模版

C++还有一种特殊的形参类型（即省略符），可以用来传递可变实参。以下做简单介绍

### initializer_list 形参

### 省略符形参















