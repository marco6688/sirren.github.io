---
title: PrimerC++-表达式
date: 2019-03-27 15:58:54
categories:
- 读书笔记
tags:
- 读书笔记
- C++
---

C++提供了一套丰富的运算符，并定义了这些运算符作用于内置类型的运算对象时所执行的操作。同时，当运算对象是类类型时，C++语言也允许由用户指定上述运算符的含义

**表达式**是由一个或多个**运算对象**组成，对表达式求值将得到一个**结果**

# 基础

## 基本概念

C++定义了一元运算符和二元运算符，作用于一元对象的是一元运算符，作用于两个对象叫做二元运算符

### 组合运算符和运算对象

对于含有多个运算符的复杂表达式，首先要理解运算符的**优先级**、**结合律**以及运算的**求值顺序**

### 对象类型的转换

对表达式求值得过程中，运算对象常常从一种类型转换成另一种类型

### 运算符重载

当运算符作用于类类型的运算对象时，用户可以自定义其含义，这种自定义的过程为已存在的运算符提供了另外一种含义称之为**重载运算符**

### 左值和右值

左值可以理解为位于赋值运算符的左侧，当一个对象被用作右值得时候用的是对象的值，当对象被用作左值的时候用的是对象的身份

## 优先级与结合律

**复合表达式**是指包含两个或多个运算符的表达式，求复合表达式首先要将运算符与运算对象合理的结合在一起，优先级与结合律决定了运算对象的组合方式。

- 括号无视优先级与结合律

## 求值顺序

优先级决定了运算对象的组合方式，但是并没有说明运算对象的求值顺序

```

int i = a()+b()*c()+d();
//上面表达式按照优先级先取得b()和c()的结果相乘
//按照结合律a的返回值与b、c返回值的乘积相加，在于d的返回值相加
//对于函数的调用顺序并没有明确规定

```

## 算术运算符

|运算符|功能|用法|
|---|---|---|
|+|一元正好|+ expr|
|-|一元负号|- expr|
|*|乘法|expr * expr|
|/|除法|expr / expr|
|%|求余|expr % expr|
|+|加法|expr + expr|
|-|减法|expr - expr|

上述运算符按照运算符的优先级将其分组，一元运算符的优先级最高，接下来是乘法除法，优先级最低的是加法减法，当运算符相同时，按照从左到右的顺序组合

- 布尔值参加运算true会被转换成1
- 进行加减乘除算数运算时，对象含有小数部分直接弃除，返回整数部分
- %取余运算符参与运算的对象必须为整数类型

## 逻辑关系运算符

结合律|运算符|功能|用法
---|---|---|---
右|!|逻辑非|!expr
左|<|小于|expr < expr
左|<=|小于等于|expr <= expr
左| \> |大于|expr > expr
左|>=|大于等于|expr >= expr
左|==|等于|expr == expr
左|!=|不等于|expr != expr
左|&&|逻辑与|expr && expr
左| \|\| |逻辑或|expr || expr

### 逻辑与和逻辑或的短路求值

当逻辑与的求职是两个运算对象的结果都为真结果为真，逻辑或则是两个运算对象一个为真则就为真。
逻辑与和逻辑或都是先求左侧值，再求右侧值。当左侧的值无法确定表达式的结果是运算符才会计算右侧的值。这种策略称为**短路求值**

### 逻辑非运算符

逻辑非运算符是对运算结果取反后返回

## 赋值运算符

- 赋值运算符左侧必须是一个可以修改的左值
- 赋值运算符两侧的对象类型不同，赋值运算符会将右侧对象转换成左侧对象类型
- 赋值运算符满足右结合律
- 赋值运算符的优先级较低

## 递增和递减运算符

递增和递减运算符是一种为对象加1和减1的简洁书写方式

## 成员访问运算符

点运算符和箭头运算符都用来访问对象属性

## 条件运算符

条件运算符语允许我们把简单的if-else操作逻辑嵌到单个表达式中

## 位运算符

位运算符作用于整数类型的运算对象，并把运算对象看作是二进制的集合，位运算符提供检查和设置二进制位的功能

运算符|功能|用法
---|---|---
- | 位求反 | -expr
<< | 左移 | expr1 << expr2
>> | 右移 | expr1 >> expr2
& | 位与 | expr & expr
^ | 位异或 | expr ^ expr
\| | 位或 | expr | expr

## sizeof运算符

sizeof运算符返回一条表达式或一个名字所占的字节数

- 对char或者类型为char的表达式执行运行运算结果得1
- 对引用类型执行得到被引用对象所占空间的大小
- 对指针执行获得指针本身所占空间的大小
- 对解引用指针执行得到指针指向对象所占空间的大小，指针不需要有效
- 对数组执行得到整个数组所占空间的大小
- 对string和vector执行返回该类型固定部分的大小，不计算对象元素占用了多少空间

## 逗号运算符

逗号运算符含有两个运算对象，按照从左到右依次求值
逗号运算符首先计算左侧运算符，然后将其丢弃，真正的返回结果是右侧的值

## 类型转换

在C++中，某些类型之间有关联，如果两种类型有关联，当程序需要其中一种类型的运算对象时，可以用另一种关联类型的对象或值来替代。

在运算过程中程序自动执行的转化称为**隐式转换**

- 大多数表达式中，比int小整数类型会提升为较大的整数类型
- 在条件中，非布尔值会转换成布尔类型
- 初始化过程中，初始值转换成变量的类型
- 在赋值语句中，右侧转换成左侧对象的类型
- 在算术运算或者关系运算的运算对象有多个类型，需要转换成同一类型
- 函数调用也会发生转换

有时候我们希望将对象强制转换成另外一个中类，成为**显示转换**

>cast-name<type>(expression)

type是转换的目标类型，expression是要转换的值，cast-name 是 static-cast、dynamic-cast、const-cast和reinterpret-cast中的一种

- 任何具有明确定义的类型转换，只要不包含底层const都可以使用static-cast
- const-cast只能改变运算对象的底层const
- reinterpret-cast通常为运算对象位模式提供较低层次的重新解释

## 运算符优先级表

运算符|描述|例子|可重载性
---|---|---|---
第一级别|||
::|作用域解析符|Class::age = 2;|不可重载
第二级别|||
()|函数调用|isdigit('1')|可重载
()|成员初始化|c_tor(int x, int y) : _x(x), _y(y*10){};|可重载
[]|数组数据获取|array[4] = 2;|可重载
->|指针型成员调用|ptr->age = 34;|可重载
.|对象型成员调用|obj.age = 34;|不可重载
++|后自增运算符|for( int i = 0; i < 10; i++ ) cout << i;|可重载
--|后自减运算符|for( int i = 10; i > 0; i-- ) cout << i;|可重载
const_cast|特殊属性转换|const_cast<type_to>(type_from);|不可重载
dynamic_cast|特殊属性转换|dynamic_cast<type_to>(type_from);|不可重载
static_cast|特殊属性转换|static_cast<type_to>(type_from);|不可重载
reinterpret_cast|特殊属性转换|reinterpret_cast<type_to>(type_from);|不可重载
typeid|对象类型符|cout &laquo; typeid(var).name();|不可重载
\||cout &laquo; typeid(type).name();|
第三级别(具有右结合性)|||
!|逻辑取反|if( !done ) …|可重载
not|! 的另一种表达||
~|按位取反|flags = ~flags;|可重载
compl|~的另一种表达||
++|预自增运算符|for( i = 0; i < 10; ++i ) cout << i;|可重载
--|预自减运算符|for( i = 10; i > 0; --i ) cout << i;|可重载
-|负号|int i = -1;|可重载
+|正号|int i = +1;|可重载
*|指针取值|int data = *intPtr;|可重载
&|值取指针|int *intPtr = &data;|可重载
new|动态元素内存分配|long *pVar = new long;|可重载
\||MyClass *ptr = new MyClass(args);|
new []|动态数组内存分配|long *array = new long[n];|可重载
delete|动态析构元素内存|delete pVar;|可重载
delete []|动态析构数组内存|delete [] array;|可重载
(type)|强制类型转换|int i = (int) floatNum;|可重载
sizeof|返回类型内存|int size = sizeof floatNum;|不可重载
||int size = sizeof(float);|
第四级别|||
->*|类指针成员引用|ptr->*var = 24;|可重载
.*|类对象成员引用|obj.*var = 24;|不可重载
第五级别|||
*|乘法|int i = 2 * 4;|可重载
/|除法|float f = 10.0 / 3.0;|可重载
%|取余数(模运算)|int rem = 4 % 3;|可重载
第六级别|||
+|加法|int i = 2 + 3;|可重载
-|减法|int i = 5 - 1;|可重载
第七级别|||
<<|位左移|int flags = 33 << 1;|可重载
>>|位右移|int flags = 33 >> 1;|可重载
第八级别|||
<|小于|if( i < 42 ) …|可重载
<=|小于等于|if( i <= 42 ) ...|可重载
>|大于|if( i > 42 ) …|可重载
>=|大于等于|if( i >= 42 ) ...|可重载
第九级别|||
==|恒等于|if( i == 42 ) ...|可重载
eq|== 的另一种表达||
!=|不等于|if( i != 42 ) …|可重载
not_eq|!=的另一种表达||
第十级别|||
&|位且运算|flags = flags & 42;|可重载
bitand|&的另一种表达||
第十一级别|||
^|位异或运算|flags = flags ^ 42;|可重载
xor|^的另一种表达||
第十二级别|||
\||位或运算|flags = flags | 42;|可重载
bitor||的另一种表达||
第十三级别|||
&&|逻辑且运算|if( conditionA && conditionB ) …|可重载
and|&&的另一种表达||
第十四级别|||
\|\||逻辑或运算|if( conditionA || conditionB ) ...|可重载
or|||的另一种表达||
第十五级别(具有右结合性)|||
? :|条件运算符|int i = (a > b) ? a : b;|不可重载
第十六级别(具有右结合性)|||
=|赋值|int a = b;|可重载
+=|加赋值运算|a += 3;|可重载
-=|减赋值运算|b -= 4;|可重载
*=|乘赋值运算|a *= 5;|可重载
/=|除赋值运算|a /= 2;|可重载
%=|模赋值运算|a %= 3;|可重载
&=|位且赋值运算|flags &= new_flags;|可重载
and_eq|&= 的另一种表达||
^=|位异或赋值运算|flags ^= new_flags;|可重载
xor_eq|^=的另一种表达||
|=|位或赋值运算|flags |= new_flags;|可重载
or_eq||=的另一种表达||
<<=|位左移赋值运算|flags <<= 2;|可重载
>>=|位右移赋值运算|flags >>= 2;|可重载
第十七级别|||
throw|异常抛出|throw EClass(“Message”);|不可重载
第十八级别|||
,|逗号分隔符|for( i = 0, j = 0; i < 10; i++, j++ ) …|可重载


