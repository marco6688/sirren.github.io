---
title: PrimerC++-变量和基本类型
date: 2019-03-05 16:41:31
categories:
- 读书笔记
tags:
- 读书笔记
- C++
---

# 基本内置类型

c++定义了一套包括算数类型和空类型的基本数据类型，算数类型包含字符、整型数、布尔值和浮点数。空类型不对应具体的值。


## 算数类型

算数类型分为整型（包含字符串和布尔类型在内）和浮点型。

算数类型的尺寸在不同的机器有所差别，下表列出来C++标准规定的尺寸最小值，同时允许编译器赋予这些类型更大的尺寸。

| 类型 | 含义 | 最小尺寸 |
| --- | ---- | ---- |
| bool | 布尔类型 | 未定义|
| char | 字符 | 8位 |
| wchar_t | 宽字符 | 16位 |
| char16_t | Unicode字符 | 16位 |
| char32_t | Unicode字符 | 32位 |
| short | 短整型 | 16位 |
| int | 整型 | 16位 |
| long | 长整型 | 32位 |
| long long | 长整型 | 64位 |
| float | 单精度浮点数 | 6位有效数字 |
| double | 双精度浮点型 | 10位有效数字 | 
| long double | 扩展精度浮点数 | 10位有效数字 |

- 布尔类型的取值是真和假
- char的空间应确保可以存放基本字符中任意字符对应的数字值，一个char的大小和一个机器字节一样
- 其他字符用于扩展字符集
- 除字符和布尔类型外，其他整型用于表示不同尺寸的整数。C++规定一个int至少和一个short一样大，一个long至少和一个int一样大，一个long long 至少和一个long一样大
- 浮点数可以表述单精度，双精度和扩展精度值

去除布尔类型和扩展类型，其他整型都可以划分为带符号的和无符号的。通过unsigned声明无符号

## 类型转换

当程序在某一处我们使用了一种类型而实际对象应该取另一种类型时，程序会进行类型转换。

- 当我们把一个非布尔类型的算术赋给一个布尔类型时，初始值为0则结果为false，否则为true
- 当我们把一个布尔值赋给非布尔类型时，初始值为false则结果为0。true则结果为1.
- 当我们把一个浮点数赋值给整数时，进行近似处理，保留小数之前的部分
- 当我们把一个整数赋值给浮点数时，小数部分记0，如果该整数所占空间超过浮点数的容量，

# 变量

变量的定义形式是:首先是类型说明符，随后紧跟一个或者多个变量名组成的列表，其中变量名以逗号分割，最后以分号结束。定义时还可以为一个或者多个变量赋值。

```C++

int sum = 0,value, //sum和value和ubits_sole都是int
units_sold = 0;     //sum和ubits_sole的初始值是0
Sales_item item     //item是Sales_item类型
std::string book("0-100-22222-X");//book是通过string字面值初始化的

```
### 初始化 

当对象在创建的时获得了一个特定的值，这个对象给*初始化*了。初始化不是赋值，初始化的含义是创建一个变量的时候赋予一个初始值，而赋值的含义是把当前对象的值擦除，用一个新值代替。

#### 列表初始化

```c++

int units_sold = 0;
int units_sold = {0};
int units_sold{0};
int units_sold(0);

```

以上的四种方法都可以将一个int的变量初始化为0，作为C++11的新标准用花括号初始化变量得到了全面的应用。

我们将一个大的变量赋值给一个较小的变量，当存在丢失信息风险时，使用花括号编译器会拒绝转换请求。

#### 默认初始化

定义变量没有指定初始值，则这个变量被默认初始化，默认值的内容由变量类型决定，定义变量位置也会对此产生影响。

#### 变量声明和定义的关系

一个变量只能定义一次，却可以声明多次。

再分离式编译中，如果在多个文件中使用了同一个变量，就必须将声明和定义分离，变量定义必须出现在切只能出现在一个文件中，而其他用到改变量的文件必须对其进行声明，决不能重复定义


```C++

extern int i;   //声明了i
int j;          //定义了j
extern double pi = 3.1416;//由于赋值抵消了什么，这是定义了pi 

```

#### 标识符

标识符是由字母、数字和下划线组成，必须是以字母和下划线开头，对长度没有限制，但是对大小写字母敏感。

C++本身保留了一些名字供自身使用，这些名字不能作为标识符。

C++标准库也保留了一些名字，用户自定义的标识符中不能出现连续的两个下划线，也不能以下划线紧连大写字母开头。定义函数体外的标识符不能以下划线开头。


##### 变量命名规范

- 标识符能体现实际含义
- 变量名一般用小写字母
- 用户自己定义的类名一般以大写字母开头
- 如果标识符由多个单词组成，则单词间应有明显的区分。 

#### 作用域

不论在程序的什么位置，使用到的名字都会指向一个特定的实体：变量、函数、类型等。然而同一个名字出现在不同的位置，也能指向不同的实体。

作用域是程序的一部分，在其中名字有其特定的意义，在C++中作用域用花括号分割。

```C++

#include <iostream>;
int main(){

    int sum=0;
    for(int val=0;val<=10;val++){
        sum+=val;
    }
    std::cout << "sum of 1 to 10 inclusive is"
              << sum << std::endl;
    return 0;

}

```

程序中使用了3个名字：main、sum、val，同时使用了命名空间std，该空间提供了两个名字cout和cin供程序使用

main定义于花括号之外，拥有*全局作用域*。

sum定义于函数main的作用域内，超出了作用域就无法使用了成为*块作用域*

作用域可以嵌套，内层作用域可以访问外层作用域变量。

# 复合类型

*复合类型*是指基于其他类型定义的类型

## 引用

引用为对象起另一个名字，引用类型学引用另外一种类型通过将声明符写成&d的形式来定义引用类型，其中d是变量名

- 引用必须被初始化
- 引用并非对象，他只是为已经存在的对象所起的另外一个名字
- 引用的值必须是一个对象
- 引用的类型初始化时必须与对象的类型相同

## 指针

指针是另外一种复合类型，指针与对象的不同点：

- 指针本身就是一个对象，允许对指针的赋值和拷贝，而且在不同的生命周期可以指向不同的对象。
- 指针无需在定义时赋值

### 定义方法

- 指针存放的是某个对象的地址，获得改地址使用取址符（&）

- 指针的类型必须与他所指的对象类型必须相同

```c++
int *p1,*p2; //定义两个整数指针

int ival=1;
int *p=&ival;// 定义一个整数指针并指向ival地址

```


### 指针值

使用解引用符（*）来访问对象

指针的值有四个状态：

- 指向一个对象
- 指向所占对象的下一个位置
- 空指针，没有指向任何对象
- 无效指针，上述情况之外的其他值

##复合类型的声明

变量的定义包括一个基本数据类型和一组声明符，在同一条语句中基本数据类型只有一个，但是声明符却可以不同

```c++

//以下语句声明了一个整数i，整型指针p，整型引用r
 int i=1;*p=&i;&r=i
 
 ```
### 指向指针的指针

声明符中修饰符的个数没有限制，由于指针本身就是一个对象，所以就会出现指向指针的指针

### 指向指针的引用

引用不是对象，所以不能定义指向引用的指针。指针是对象，所以存在指向指针的对象。

# const限定符

定义常量是使用const关键字，默认状态下const对象仅在当前文件有效，解决办法是对于const变量不管是声明还是定义都添加extern关键字，这样只需定义一次
 
### const的引用

可以把引用绑定到const对象上，我们称之为*对常量的引用*，与普通的引用不同的是我们不能修改他所绑定的对象。

- 引用及其对对应象都是常量
- 对const的引用可能引用一个并非const的对象

### 指针与const

指针也可以指向常量和非常量，类似于常量引用，*指向常量的指针*不能用于改变其所指对象的值想要存放常量对象的地址，只能使用常量指针

- 和引用一样，常量和其对应的对象必须是同一类型
- 允许常量指针指向普通变量
- 常量指针必须初始化，一旦初始化完成常量的值就不能改变了
#### 顶层const

```c++

int i =0;

int *const p1 = &1;     //不能改变p1的值，是顶层const
const int c1 =42;       //不能改变c1的值，是顶层const
const int *p2 = &ci;    //允许改变p2的值，是底层const
const int *const p3 = p2;//靠右的const是顶层，靠左的是底层
const int &r=ci；        //所有引用的const都是顶层const

```
#### constexpr

常量表达式是指不会改变并且在编译过程中就会得到计算结果的表达式，

C++ 11新标准规定允许将变量声明为constexpr类型以便由编译器验证变量是否是一个常量表达式，








